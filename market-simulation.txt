---
The Real-Time Market Simulation project was born from my curiosity about market microstructure and algorithmic trading mechanics. Instead of using traditional simulation environments, I decided to leverage my experience in embedded systems and use ESP32 microcontrollers as individual trading nodes, each representing a market participant with its own trading strategy. This allows me to encounter real world bottle necks and issues, and much more closely represents the close locality of real scenarios and technology of trading systems, such as using UDP multicasts. 

Emed youtube video here for demonstration. 

## System Architecture

The system is made up of three main components:

* **Market:** A central server running on a desktop computer. This is the brain of the system—it keeps track of the order book, matches orders, and executes trades.
* **ESP32 Trader Nodes:** These are tiny microcontrollers simulating individual traders using basic trading strategies.
* **Desktop Trader Nodes:** Similar to the ESP32s, but running on full-fledged desktop machines for more compute-heavy testing.
* **Shared Library:** A cross-platform library used by all the trading clients to ensure consistent behavior across devices.
* **Desktop Terminal:** A Blazor-based monitoring UI that shows what's going on in real time—useful for visualizing market activity and debugging issues.

---

## Key Features

### Market Engine

The market engine is built in C++20 and is responsible for:

* Matching and executing orders.
* Broadcasting L1 market data over UDP.
* Receiving new orders over TCP.
* Recording historical trades using a basic replay engine for later analysis.

It’s designed to be lightweight, fast, and modular.

---

### Trader Nodes

Each trader node runs independently and acts like its own autonomous participant in the market. Right now, I’ve implemented three very basic trading strategies:

* **Market Maker:** Places both bid and ask orders to provide liquidity.
* **Market Taker:** Aggressively buys or sells at the best available price.
* **Random:** Just throws random orders within a price range—useful for stress testing and simulating noise.

Each strategy is implemented by extending a shared `MarketClient` class and overriding the `Think()` method. This method is called repeatedly and makes trading decisions.

---

### Shared Library

To keep things clean and consistent, I created a shared library that contains all the common logic, including the core strategy code. This library exposes a simple `DeviceInterface` that each platform implements based on its capabilities.

Here’s what that interface looks like:

```cpp
class DeviceInterface {
public:
    virtual void        Send( const void * data, int size ) = 0;
    virtual bool        Recv( PacketBuffer & buffer ) = 0;
    virtual void        DisplayHeaderText( const char * text ) = 0;
    virtual void        DisplayTrade( const char * text, int price, int quantity ) = 0;
    virtual void        Log( const char * text ) = 0;
};
```

Each trader then inherits from `MarketClient`:

```cpp
class MarketClient {
public:
    MarketClient( Strategy strat, DeviceInterface * device ) : device( device ), strategy( strat ) {}

    virtual void Think() = 0;

protected:
    void PlaceOrder( RpcCall call, const OrderEntry & order );
    DeviceInterface * device;

private:
    Strategy strategy;
};
```

So if you want to write a new trader, all you need to do is implement the interface and the `Think()` method. Easy.

---

## Challenges I Faced

### 1. **Throughput & Latency**

One of my main goals was to push as many orders per second (OPS) as possible. But early on, I hit some major bottlenecks—especially on the ESP32 nodes.

#### Context Switch Hell

Originally, the `Recv()` function on the ESP32 would block using a conditional variable:

```cpp
device->Recv( buffer ); // Blocking call
```

Turns out, this was adding a **massive 50ms+ delay** due to context switching. The ESP32 only has two cores, so if one task blocked, it took forever to resume. The fix? I swapped the blocking call for a spinning loop:

```cpp
while ( device->Recv( buffer ) == false ) {}
```

Not elegant, but much faster for our use case.

---

### 2. **Memory Limitations on ESP32**

The ESP32 only has 4MB of flash memory, and when market data was coming in too fast, the lock-free queue storing the data would eventually blow up and crash the device.

Solution? Evict old data. If it hasn’t been processed in time, it’s probably outdated anyway.

---

### 3. **Lock-Free Queues Everywhere**

To avoid blocking and keep the system snappy, I used lock-free queues for just about everything. The idea was to keep the hot path (matching and resolving orders) as clean as possible and push all non-critical work (like logging, metrics, order replies) to other threads.

---

### 4. **Network Bandwidth**

Even with the above fixes, I eventually hit a wall—network bandwidth.

ESP32 Ethernet adapters are limited to 100 Mbps. In practice, most people only get 20–40 Mbps, though with UDP optimization, you can push closer to 80 Mbps. I benchmarked my system and, sure enough, my ESP32s were hitting \~80 Mbps already.

So the next optimization had to come from reducing how much data I send.

---

### 5. **Trimming the Order Structure**

Here’s what my original order looked like:

```cpp
struct OrderEntry {
    i64         id = 0;
    i64         time = 0;
    i64         price = 0;
    i64         quantity = 0;
    OrderType   type = OrderType::MarketOrder;
    Symbol      symbol;
};
```

This was convenient because I used the same structure for everything. But it’s wasteful—traders don’t set `id` or `time`, so sending them is pointless.

Here’s the slimmed-down version:

```cpp
#pragma pack(push, 1)
struct IncomingOrder {
    i64         price;
    i32         quantity;
    OrderType   type = OrderType::MarketOrder;
    Symbol      symbol;
};
#pragma pack(pop)
```

This cuts down the payload size, removes padding, and keeps everything tight. Future versions might pack flags or metadata into the extra bytes if needed.

With this change, I was able to push XXX orders per second per device—a XXX% improvement.

---

## Future Improvements

* **Switch to Raspberry Pi:** The ESP32 is great, but 240 MHz and 4MB flash only gets you so far. A Raspberry Pi (or similar SBC) would give me much more CPU power and better networking performance.
* **Better Trading Algorithms:** The current strategies are very basic and mostly useful for stress testing. I’d love to implement more realistic algorithms like:

  * Latency arbitrage
  * Iceberg orders
  * Front-running detection
  * Adversarial slow/fake clients
* **Order Book Visualization:** Expand the Blazor terminal to show a full depth-of-book view, along with volume over time and spread charts.
* **Protocol Compression:** Explore ways to compress or binary-pack multiple orders into a single packet.
* **Persistence Layer:** Add a persistent store for trades, replays, and market state snapshots.
* **Strategy Scripting:** Let trader nodes load strategies from a Lua or WASM runtime so I don’t have to recompile for every tweak.

---

## Final Thoughts

This project started out as a fun way to play with market mechanics and microcontrollers—but it’s grown into a proper testbed for low-latency systems, embedded performance profiling, and systems architecture. There’s still a ton to improve, but it’s already been incredibly educational.

If you’re into systems programming, trading, or embedded development, I highly recommend building something similar. You learn *a lot* by simulating a real-world system end to end.

I’ll keep posting updates as I go—stay tuned.

---
